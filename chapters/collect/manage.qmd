# Organiser ses fichiers {#sec-collect-files}

Le principe fondamental à suivre pour améliorer l'organisation de ses dossiers et fichiers est simplement d'avoir une stratégie et de s'y tenir. L'une des principales motivations pour bien organiser ses fichiers est de faciliter leur utilisation, à la fois pendant la durée de l'analyse et à l'avenir, lorsque vous ou d'autres personnes les utiliserez. Si vos fichiers sont bien organisés, une personne qui n'est pas familière avec votre projet (ce qui pourrait aussi être vous dans le futur) devrait être capable de les regarder et de comprendre rapidement en détail ce que vous avez fait et pourquoi [@noble2009]. Une deuxième motivation réside dans le caractère souvent itératif de l'analyse de données : tout ce que vous faites pendant votre analyse, vous aurez probablement à le refaire. Nous explorons généralement de nombreuses options analytiques avec nos données, de sorte que le processus d'analyse ressemble davantage à un arbre ramifié qu'à une séquence unique d'actions consécutives. Nous revenons souvent à une étape antérieure de l'analyse pour étudier l'effet de la sélection de données particulières ou de l'ajustement des paramètres d'un modèle. Si nous avons organisé et documenté clairement notre travail, il sera beaucoup plus facile de répéter les étapes précédentes de l'analyse avec des variations mineures.

## Travailler par projets {#sec-collect-files-project}

Une bonne pratique liée à l'utilisation de R consiste ainsi à [organiser l'ensemble de son analyse en un projet](https://rstats.wtf/project-oriented-workflow.html), c'est à dire un dossier autonome contenant l'ensemble des fichiers nécessaires à l'analyse (dont les données brutes et les fichiers générés en cours d'analyse). Une telle organisation doit permettre de déplacer le dossier sur son ordinateur ou sur un autre ordinateur, tout en maintenant le bon fonctionnement du code (absence de liens brisés, de dépendances manquantes...). Ce dossier, appelé répertoire de travail (*working directory*), doit être **portable**.

Le répertoire de travail est un concept important à comprendre, car il diffère de la façon dont on travaille avec un tableur. Le répertoire de travail est le répertoire (ou dossier) de votre ordinateur dans lequel R va travailler. Il s'agit de l'emplacement sur votre ordinateur où R cherchera lorsque vous lirez des fichiers ou enregistrerez des résultats. Par défaut, le répertoire de travail a probablement été défini dans un répertoire peu pratique lors de l'installation de R, mais il est facile de le modifier.

Le répertoire de travail peut être défini ou retrouvé à l'aide des fonctions `setwd()` et `getwd()`, respectivement :

```{r, eval=FALSE}
# Définition du répertoire de travail
setwd("/chemin/vers/mon/dossier")
```

Une fois le répertoire de travail défini, toute référence à un fichier en utilisant un simple nom de fichier ou un chemin relatif sera interprétée relativement au répertoire de travail.

Cependant, cette approche n'est pas recommandée car le risque est de se retrouver dans la situation suivante :

```{r, eval=FALSE}
# Définition du répertoire de travail
setwd("/chemin/uniquement/valide/sur/mon/ordinateur")
```

Si vous utilisez la commande `setwd()` pour définir le répertoire de travail, votre code ne fonctionnera que sur votre ordinateur, dans sa configuration actuelle de fichiers et de dossiers. Cela signifie que votre code n'est pas portable et n'est pas robuste face au changement. Si vous réorganisez vos fichiers ou si vous donnez votre code à un collaborateur, le répertoire de travail réel où se trouvent vos fichiers ne correspondra plus à ce qui est écrit dans le code. Cela peut entraîner des erreurs et de la frustration. Ainsi, bien qu'il soit important de connaître le concept de répertoire de travail pour travailler avec R, vous ne devez pas inclure sa définition dans votre code R.

Pour pallier ce problème qui rend difficilement déplaçable un dossier de projet, il existe différentes solutions (utilisable conjointement) parmi lesquelles :

* L'utilisation du package [*here*](https://here.r-lib.org/),
* L'utilisation de la gestion de projet dans RStudio.

:::{.callout-tip}
RStudio dispose d'un mécanisme permettant de [créer facilement de tels projets](https://support.rstudio.com/hc/en-us/articles/200526207-Using-Projects). Il est possible de créer un projet dans RStudio à partir du menu déroulant situé en haut à droite de l'interface ou en cliquant sur *New Project...* depuis le menu *File*. Le projet peut alors être créé soit dans un nouveau dossier, soit en transformant un dossier existant (@fig-rstudio-project).

Un projet créé par RStudio est reconnaissable par la présence d'un fichier `.Rproj`. Ce fichier marque le dossier de plus haut niveau au sein d'un projet (répertoire de travail), à partir duquel des chemins d'accès relatifs peuvent être utilisés pour lire ou écrire des fichiers. Le répertoire de travail est automatiquement définit lors de l'ouverture d'un projet RStudio : il n'est plus nécessaire d'utiliser `setwd()`.
:::

```{r}
#| label: fig-rstudio-project
#| echo: false
#| out-width: '70%'
#| fig-cap: "Création d'un projet avec RStudio."
knitr::include_graphics(here::here("images/rstudio-project.png"))
```

Il peut être nécessaire que votre code fasse référence à d'autres répertoires par rapport au répertoire principal de votre projet (par exemple, un répertoire appelé "data" qui contient des feuilles de calcul, etc.). L'organisation des fichiers et des sous-dossiers au sein d'un projet relève des habitudes de travail de chacun. S'il n'existe pas de consensus sur la manière d'organiser les fichiers à l'intérieur d'un projet, il peut cependant être avantageux de suivre certaines conventions (@fig-xkcd-documents).

```{r}
#| label: fig-xkcd-documents
#| echo: false
#| out-width: '50%'
#| fig-cap: "Documents. \"Copy of Copy of Copy of Copy of Copy of Copy of Copy of Copy of Copy of Copy of Copy of Copy of Copy of Copy of Copy of Copy of Copy of Copy of Copy of Copy of Copy of Copy of Copy of Copy of Copy of Copy of Copy of Copy of Copy of Copy of Copy of Copy of Copy of Untitled.doc\" [CC BY-NC 2.0 @munroe2014]."
knitr::include_graphics(here::here("images/xkcd_documents.png"))
```

## Organiser ses fichiers {#sec-collect-files-organize}

Au-delà d'avoir une stratégie pour organiser ses dossiers et fichiers, il existe plusieurs lignes directrices qui ont été proposées par des biologistes et des écologistes et qui sont applicables à la recherche archéologique [@noble2009; @white2013]. Ces recommandations reposent sur un principe élémentaire qui veut que l'organisation des fichiers indique les entrées et les sorties, ainsi que le flux d'informations pendant l'analyse des données. Les recommandations les plus importantes sont que (1) les données brutes doivent être séparées des données dérivées, et (2) les données doivent être séparées du code.

Les **données brutes** désignent les fichiers de données tels qu'ils étaient lorsque vous les avez reçus à l'origine, par exemple transcrits à partir d'un cahier, saisis directement dans une base de données ou un tableur, ou téléchargés à partir d'un instrument tel qu'une station totale ou un analyseur XRF. Les **données dérivées** sont les données qui résultent des actions que vous entreprenez après avoir reçu les fichiers de données. Il s'agit de manipulations manuelles, telles que des modifications dans une feuille de calcul et de manipulations programmatiques qui se produisent lorsque vous utilisez R pour produire une version actualisée de vos données. Les manipulations manuelles sont à éviter autant que possible, car elles ne laissent aucune trace --- contrairement à une manipulation effectuée par un script --- ce qui les rend difficiles à défaire si vous changez d'avis. Si une manipulation manuelle est nécessaire dans vos données, vous devriez conserver un fichier de texte brut avec le fichier de données et y consigner un bref récit des modifications apportées afin d'en avoir une trace. Une façon simple de séparer les données brutes des données dérivées consiste à avoir un dossier appelé `data/` qui contient deux répertoires, `raw_data/` et `derived_data/` (voir le schéma ci-dessous). L'utilisation d'une structure simple comme celle-ci signifie que vous n'avez besoin que d'une seule copie des fichiers de données originaux dans votre projet, plutôt que de les dupliquer à travers toute votre structure de fichiers (ce qui peut être une source de confusion importante pour savoir quel fichier est le bon).

```
├── data/              # Données brutes et dérivées
|   ├── raw_data/      # Données brutes collectées avant l'analyse
|   └── derived_data/  # Données générées au cours de l'analyse
```

Cette pratique consistant à conserver les données brutes isolées de tout le reste signifie que vous êtes toujours en mesure de revenir aux premières étapes de votre analyse (lecture des données brutes) au cas où vous auriez besoin d'explorer une autre voie ou de vérifier vos résultats. Ce point est essentiel pour garantir la reproductibilité de votre recherche et pour avoir l'esprit tranquille en sachant que vous pouvez vérifier vos résultats. Si vous apportez de nombreuses modifications à vos fichiers de données brutes au cours de votre analyse, vous ne pourrez peut-être jamais revenir au début de votre analyse, vous n'aurez pas la possibilité de vérifier vos résultats et votre travail sera impossible à reproduire. Le fait de conserver les données brutes intactes offre également aux autres chercheurs davantage d'options lorsqu'ils réutilisent vos données, ce qui augmente la valeur de votre travail pour l'ensemble de la communauté scientifique.

Le second principe d'organisation des fichiers dont nous pouvons nous inspirer des biologistes et des écologistes est étroitement lié au premier : les données sont séparées du code. Utiliser un tableur est une façon très peu naturelle de travailler. Dans une feuille de calcul, les formules qui calculent à partir les données sont situées directement à côté des cellules qui contiennent les données (par exemple, dans les lignes à droite ou sous les données). Bien que cela puisse être pratique pour travailler avec de petits tableaux de données, il est rapidement difficile de distinguer les données brutes des données dérivées et de distinguer les données et les méthodes (c'est-à-dire les fonctions dans les cellules de la feuille de calcul). Ce mélange des données et des méthodes est un obstacle majeur à la reproductibilité et à l'ouverture de la recherche, car la séquence des décisions prises au cours de l'analyse n'est pas explicite.

Votre code changera fréquemment pendant que vous travaillez, mais vos données brutes ne devraient être modifiées. Si vous conservez ces fichiers dans des dossiers séparés, vous serez moins tenté de modifier les données brutes à la main pendant que vous écrivez du code. Il s'agit d'un principe de base de la conception de logiciels, qui permet de minimiser la confusion lors de la navigation dans les fichiers d'un projet. Une raison supplémentaire devant conduire à séparer le code et les données est que vous pouvez ne pas être en mesure de partager vos données brutes (par exemple, elles peuvent contenir des informations sensibles sur l'emplacement de sites archéologiques), mais vous pouvez être disposé à partager votre code. Lorsque ces deux composantes du projet sont bien séparées, il est facile de contrôler ce qui peut être rendu public et ce qui doit rester privé. Voici un exemple de structure de dossier de projet qui montre comment le code et les données peuvent être séparés :

```
├── data/              # Données brutes et dérivées
|   ├── raw_data/      # Données brutes collectées avant l'analyse
|   └── derived_data/  # Données générées au cours de l'analyse
|
├── scripts/           # Tout code, par exemple des fichiers de script R
```

Une troisième recommandation consiste à garder les fichiers associés à la production de manuscrits ou de rapports séparés de tout le reste. Dans l'exemple ci-dessous, cela est représenté par le répertoire `paper/`. Ce dossier contient un (ou plusieurs) fichiers R Markdown qui documentent l'analyse sous une forme exécutable. Cela signifie qu'il devrait être possible de convertir le document R Markdown en un fichier HTML/PDF/Word présentant les principales méthodes, décisions et résultats de l'analyse. Ce fichier R Markdown peut, par exemple, importer le code d'un script présent dans dans le répertoire `scripts/` en utilisant la fonction `source()`. Cet exemple montre également comment organiser les figures et autres images :

```
├── data/              # Données brutes et dérivées
|   ├── raw_data/      # Données brutes collectées avant l'analyse
|   └── derived_data/  # Données générées au cours de l'analyse
|
├── scripts/           # Tout code, par exemple des fichiers de script R
|
├── figures/           # Figures produites au cours de l'analyse
|
├── paper/             # Rédaction du manuscrit
|   ├── paper.Rmd      # Un ou plusieurs fichier R markdown
|   └── references.bib # Fichier bibliographique
```

Une dernière recommandation est d'avoir un répertoire `scratch/` (brouillon) dans lequel expérimenter. Ce répertoire doit contenir des bribes de code et des résultats produits lors de courtes excursions sur des voies alternatives lors de l'analyse (lorsque vous voulez explorer certaines idées, mais que vous n'êtes pas sûr qu'elles seront pertinentes pour l'analyse principale). Si l'expérimentation s'avère utile, vous pouvez alors l'incorporer à l'endroit approprié dans les dossiers du projet principal. Si l'expérience n'est pas directement pertinente, vous pouvez la laisser dans le répertoire `scratch/` ou la supprimer (tout ce qui se trouve dans ce répertoire doit pouvoir être supprimé à tout moment sans aucune conséquence pour votre projet). En général, le répertoire `scratch/` est supprimé après la soumission ou la publication de l'article.

Enfin, une recommandation supplémentaire peut être formulée, bien qu'elle ne relève pas de la même logique. Elle consiste à inclure un fichier texte simple nommé "README" (par exemple "README.txt" ou "README.md") à la racine de l'arborescence des fichiers d'un projet. Ce fichier est destiné à documenter quelques détails de base sur le projet. Cela peut inclure une douzaine de lignes de texte fournissant le nom du projet, les noms des personnes impliquées, une brève description du projet et un bref résumé du contenu des dossiers du projet. Vous pouvez également inclure des fichiers README similaires dans d'autres dossiers de votre projet, par exemple pour documenter les paramètres des instruments qui sont importants pour l'utilisation des données brutes. Vous trouverez ci-dessous un exemple de projet comprenant un répertoire brouillon et un fichier README :

```
├── data/              # Données brutes et dérivées
|   ├── raw_data/      # Données brutes collectées avant l'analyse
|   └── derived_data/  # Données générées au cours de l'analyse
|
├── scripts/           # Tout code, par exemple des fichiers de script R
|
├── scratch/           # Expériementations (peut être supprimé)
|
├── figures/           # Figures produites au cours de l'analyse
|
├── paper/             # Rédaction du manuscrit
|   ├── paper.Rmd      # Un ou plusieurs fichier R markdown
|   └── references.bib # Fichier bibliographique
|
├── README.txt         # La description du projet et de son contenu
```

Ces recommandations sont largement applicables à la plupart des projets archéologiques, quelle que soit leur échelle ou leurs méthodes. Certains ajustements peuvent être nécessaires pour les jeux de données volumineux, distant ou contenant des informations sensibles (de même dans les situations où les calculs prennent beaucoup de temps). Dans tous les cas, le principe général de séparation doit gouverner les décisions prises en matière d'organisation des fichiers.

:::{.callout-tip}
Le package [*rrtools*](https://github.com/benmarwick/rrtools) permet de structurer rapidement son travail en suivant certaines conventions d'organisation des fichiers.
:::

## Nommer ses fichiers {#sec-collect-files-name}

En tant qu'archéologues, nous sommes habitués à nommer les choses, lorsque nous faisons face à des objets qui ne correspondent pas exactement aux typologies existantes ou lorsque nous identifions des fragments d'objets qui n'ont pas d'attributs distinctifs [@kleindienst2006; @ferris1999]. Nous faisons souvent attention lorsque nous nommons des objets, car les noms sont une forme de communication et privilégient certaines interprétations et significations par rapport à d'autres. Souvent, en tant qu'archéologues, lorsque nous attribuons un nom, nous donnons naissance à quelque chose et délimitons ses frontières. Nous discutons de la signification des noms, tels que "Paléolithique moyen" ou "Acheuléen".

Les nombreux produits numériques de notre travail analytique sont rarement rendus publics, si bien que nous ne mettons pas autant de soin et d'efforts à les nommer. De nombreux archéologues considèrent que les fichiers créés dans le cadre de l'analyse des données d'un projet sont leur propriété privée et peuvent être utilisés en l'état. Ils ne pensent donc pas à les nommer de manière à gagner du temps et à faciliter la recherche de ces fichiers. Ceci est peut-être moins vrai dans les grands projets, mais par expérience, en travaillant avec une douzaine de collaborateurs ou plus, le nommage des fichiers est souvent chaotique. Voici un exemple de noms de fichiers mal choisis :

```
resumé.docx
figure 1.png
Fig 2.png
article FINAL v.3 Jan22 introcorrigée.pdf
```

Pour remédier à ce chaos et rendre les fichiers plus faciles à (ré)utiliser, nous pouvons suivre un principe élémentaire pour nommer les fichiers : les noms de fichiers doivent lisibles à la fois par les machines et par les humains. Rendre les noms de fichiers lisibles par les humains signifie inclure des informations sur le contenu du fichier dans son nom. Lorsqu'un nom de fichier contient des informations sur son contenu, il est facile pour les autres utilisateurs de comprendre ce qu'est le fichier et de décider comment l'utiliser. Voici les fichiers précédents renommés en suivant cette directive :

```
2022-01-17_resume_eaa.docx
fig01_dispersion-lithique-silex.png
fig02_histogramme-lithique-silex-eclats.png
```

Une attention particulière doit ainsi être portée à trois éléments. Le premier point consiste à ne pas utiliser d'espaces, de signes de ponctuation (à quelques exceptions près) ou de caractères exotiques tels que les accents. Ceci en veillant à un usage cohérent de la casse des caractères, car pour une machine les majuscules et les minuscules d'une même lettre sont presque aussi différentes que A et Z le sont pour nous.

Le second point consiste à nommer les fichiers de sorte qu'il est possible d'en extraire de l'information. De tels noms de fichiers utilisent délibérément des délimiteurs tels que le trait d'union (`-`) et le trait de soulignement (`_`). Dans les exemples ci-dessus, les traits d'union sont utilisés pour délimiter les chiffres et les mots dans le nom des fichiers. Le trait de soulignement est, quant à lui, utilisé pour délimiter les unités de métadonnées, par exemple pour séparer la date de la description, ou le numéro de figure de sa description. Cette utilisation des délimiteurs permet d'extraire des métadonnées des noms de fichiers. Par exemple, on peut obtenir des données pertinentes pour notre analyse à partir des noms de fichiers suivants :

```{r}
# Lister les fichiers
(fichiers <- list.files("data/raw_data/"))

# Découper les noms de fichiers
# (récupère les informations contenues dans les noms)
info <- strsplit(fichiers, split = "_")

# Construire un tableau de métadonnées
as.data.frame(do.call(rbind, info))
```

L'utilisation judicieuse des délimiteurs peut alors rendre le travail avec un grand nombre de fichiers très aisé. En effet, il alors possible utiliser R pour rechercher des fichiers ou des groupes de fichiers spécifiques et extraire les informations contenues dans les noms de fichiers, comme illustré ci-dessus.

Le troisième point consiste à s'assurer que les noms de fichiers vont être automatiquement triés de manière pertinente. La façon la plus simple de le faire est d'ajouter un préfixe numérique, comme une date ou une autre séquence de chiffres.

:::{.callout-tip}
Pour classer des fichiers par date vous devez utiliser la norme ISO 8601 (`AAAA-MM-JJ`), afin d'obtenir un tri par année, mois puis jour.

Par défaut, la plupart des systèmes d'exploitation considèrent les chiffres dans les noms de fichiers comme des caractères. Ainsi, des fichiers préfixés par `1_`, `2_`, `3_`... seront triés de manière non naturelle, car `10_` sera placé entre `1_` et `2_`, plutôt qu'après `9_`, comme vous vous y attendriez. Pour obtenir un tri naturel, vous devez donc ajouter des zéro non significatifs à gauche, par exemple : `001_`, `002_`, `003_`, etc. (les valeurs 10 à 19 seront ainsi reconnues par votre ordinateur comme supérieures à 2). Ce principe est également valable lorsque les noms de fichiers sont préfixés par des caractères, par exemple : `Fig-01_`, `Fig-02_`, `Fig-03_`, etc.
:::
