# (PART) Premiers pas avec R {-}

# Prise en main
## Invite de commande

R se présente sous la forme d'une [interface en ligne de commande](https://fr.wikipedia.org/wiki/Interface_en_ligne_de_commande), permettant de donner des instructions à l'ordinateur. Dans RStudio, cette interface est accessible dans l'onglet *Console*.

Lorsque R est en cours d'exécution, l'interface signifie qu'elle est prête à recevoir des instructions par une invite de commande (*prompt*) indiquée par un chevron `>`.

Il est alors possible d'entrer une **expression**, qui va être **évaluée** par R avant d'en retourner le résultat :

```{r}
1 + 1
```

Sans surprise, le résultat de l'addition est 2. R donne une information supplémentaire, le `[1]` devant `2` précise qu'il s'agit du premier (dans le cas présent, du seul) élément retourné. Certaines commandes peuvent retourner plusieurs valeurs. Par exemple, l'opérateur `:` (deux-points) permet de construire des [séquences](#fonctions-sequences) de nombres entiers :

```{r}
0:100
```

La commande `0:100` retourne 101 valeurs qui sont affichées sur plusieurs lignes : le nombre entre crochet indique l'**indice** de la valeur par laquelle débute chacune des lignes (la deuxième ligne commence par la 17^e^ valeur, etc.).

::: {.rmdimportant}
Contrairement à [Python](https://www.python.org/), dans R les [indices commencent à 1](#extraction) et non à 0.
:::

Si une commande incomplète est transmise, l'invite de commande signale par un `+` que la suite des instructions peut être saisie sur plusieurs lignes : 

```{r}
1 -
1
```

::: {.rmdtip}
Il est possible d'interrompre la saisie ou d'annuler une commande avec `ctrl/cmd + c`.
:::

Si une commande erronée est transmise, R s'interrompt et retourne un message d'erreur (plus ou moins explicite) :

```{r, error=TRUE}
x
```

::: {.rmdtip}
Il est possible de naviguer dans l'historique des commandes précédemment exécutées à l'aide des flèches `haut` et `bas` du clavier.
:::

## Objets {#objets}

Il est possible d'associer un nom à une valeur et ainsi de créer des **variables** (au sens informatique) qui peuvent ensuite être appelées dans l'invite de commande. Une variables n'est rien d'autre qu'un emplacement de la mémoire de l'ordinateur, réservé pour stocker une valeur. 

Cette **affectation** (ou assignation, par anglicisme) est réalisée à l'aide de l'opérateur `<-` :

```{r}
x <- 1
x
```

Il est possible de copier une variable :

```{r}
y <- x
y
```

Une fois copié, il n'existe aucun lien entre l'objet initial et sa copie. Dans l'exemple précédent, si `x` est modifié après avoir été copié dans `y`, la valeur de `y` ne sera pas modifiée.

Il est possible d'affecter plusieurs variables en même temps :

```{r}
i <- j <- 1
```

Les variables ainsi crées peuvent être réutilisées :

```{r}
x + 1
i + j
```

La réutilisation d'un nom de variable existant entraîne le remplacement de la valeur précédente (sans avertissement) :

```{r}
i <- 1
i

i <- 2
i
```

::: {.rmdimportant}
* Un nom de variable peut uniquement être composé de lettres, de chiffres et des caractères `.` ou `_`.
* Un nom de variable doit toujours commencer par une lettre (ou par un point suivi d'une lettre).
* Les noms de variables sont sensibles à la casse (`x` et `X` sont deux variables différentes).
* Il existe des mots réservés qui ne peuvent être utilisés comme nom de variable.
:::

Dans R les variables stockent des **objets**^[En informatique, un objet est une représentation d'une entité du monde réel et de ses attributs, auxquels sont associés des traitements particuliers.]. Ainsi, le code `x <- 1` peut se lire "créer un objet nommé *x* dont la valeur est 1"^[Il s'agit cependant d'une simplification, voir la section "[Binding basics](https://adv-r.hadley.nz/names-values.html#binding-basics)" dans @wickham2019 pour plus de détails.].

Un objet possède un type et une structure de données particulière. Le type d'un objet est lié au type d'information qu'il contient et à la façon dont il est stocké dans la mémoire^[Votre système d'exploitation alloue la mémoire en fonction du type de donnée et décide de ce qui peut être stocké dans la mémoire réservée lors de la création d'une variable.]. La structure de données d'un objet correspond à la manière dont sont organisées les données.

## Fonctions {#fonctions}

Il existe des objets particuliers, qui permettent d'agir sur d'autres objets : les **fonctions**. Ces fonctions peuvent accepter une ou plusieurs valeurs (ou objets) en entrée, appelés **arguments**, et retournent un objet au terme de leur exécution. Les arguments permettent de modifier le comportement d'une fonction. 

R fournit de très nombreuses fonctions, mais pour réaliser des taches très spécifiques il est possible d'[écrire ses propres fonctions](#fonctions-ecrire) ou d'[installer des packages](#packages) supplémentaires.

### Utiliser des fonctions

Par exemple, la fonction `round()` permet d'arrondir une valeur numérique au nombre de décimales spécifié. Par défaut, la fonction `round()` réalise un arrondi à zéro chiffre après la virgule :

```{r}
round(3.141593)
```

La fonction `args()` permet de connaitre les différents arguments d'une fonction et les valeurs par défaut qui peuvent leur être associées :

```{r}
args(round)
```

La fonction `round()` accepte ainsi deux arguments, la valeur à arrondir et le nombre de décimales à conserver (0 par défaut).

::: {.rmdnote}
Les arguments qui possèdent une valeur par défaut sont des **arguments facultatifs** : ils peuvent être omis lorsque la fonction est appelée (la valeur par défaut sera utilisée). À l'inverse, les arguments sans valeurs par défaut doivent être spécifiés : ce sont des **arguments obligatoires**.
:::

Les différents arguments d'une fonction sont séparés par une virgule et sont nommés. Lors de l'appel d'une fonction, si les arguments ne sont pas spécifiés par leur nom, R va associer les valeurs correspondantes dans l'ordre. Dans l'exemple suivant, la valeur `2` est associée au second argument (`digits`) :

```{r}
round(3.141593, 2)
```

Pour éviter les erreurs et pour [faciliter la lecture du code](#style-fonction), dans un appel de fonction, spécifiez toujours les arguments par leur nom (à l'exception du premier argument). Les arguments obligatoires doivent être placés en premier, suivis des arguments facultatifs :

```{r}
round(3.141593, digits = 2)
```

::: {.rmdtip}
Le nom des arguments d'une fonction, leurs rôles et leurs éventuelles valeurs par défaut sont détaillés dans l'[aide](#aide).
:::

### Écrire des fonctions {#fonctions-ecrire}

Comme son nom le laisse deviner, fonction `function()` permet de créer ses propres fonctions. 

```{r}
addition <- function(x, y) {
  # On définit les instructions à exécuter
  z <- x + y
  # On précise le résultat à retourner au terme des calculs
  return(z)
}

addition(1, 2)
```

Il est possible de définir des arguments facultatifs et ainsi de spécifier le comportement par défaut d'une fonction.

La fonction suivante permet d'élever un nombre à la puissance désirée. En spécifiant la valeur du second argument (qui correspond à l'exposant) dans la définition de la fonction, on peut prédéfinir son comportement : par défaut, notre fonction va élever le nombre désiré au carré :

```{r}
# Définition de la fonction
# Par défaut, la valeur de y est 2
puissance <- function(x, y = 2) {
  z <- x^y
  return(z)
}

# L'utilisateur ne change pas la valeur par défaut
puissance(2) # 2 au carré

# L'utilisateur change explicitement la valeur par défaut
puissance(2, 3) # 2 au cube
```

## Packages {#packages}

Lors d'une première installation de R, un ensemble de packages contenant les [fonctions](#fonctions) fondamentales est installé :

* Les packages essentiels : `base`, `compiler`, `datasets`, `graphics`, `grDevices`, `grid`, `methods`, `parallel`, `splines`, `stats`, `stats4`, `tcltk`, `tools`, `translations`, `utils`.
* Les packages recommandés : `boot`, `class`, `cluster`, `codetools`, `foreign`, `KernSmooth`, `lattice`, `MASS`, `Matrix`, `mgcv`, `nlme`, `nnet`, `rpart`, `spatial`, `survival`.

L'installation d'un package permet de bénéficier de fonctionnalités supplémentaires, généralement dédiées à une tâche bien spécifique. Pour ne pas se perdre dans la multitude de ressources disponibles, le CRAN propose des [répertoires de packages](https://cran.r-project.org/web/views/) par domaine (*Task Views*) pour faciliter le choix des packages pour une analyse spécifique. Il existe ainsi des répertoires pour les [sciences sociales](https://cran.r-project.org/web/views/SocialSciences.html), l'analyse de [données environnementales](https://cran.r-project.org/web/views/Environmetrics.html) ou encore l'analyse de [données spatiales](https://cran.r-project.org/web/views/Spatial.html). Pour l'archéologie, il existe une [*Task View* non officielle](https://github.com/benmarwick/ctv-archaeology), maintenue par Ben Marwick.

::: {.rmdtip}
Une bonne pratique consiste à toujours chercher à [limiter les dépendances](#dependances).
:::

Lorsqu'un package est disponible sur le CRAN, il peut aisément être installé à l'aide de la fonction `install.packages()`^[`install.packages()` permet également d'installer des packages publiés sur d'autres dépôts que le CRAN, comme [Bioconductor](https://www.bioconductor.org/).].

La commande suivante permet d'installer le package [*folio*](https://packages.tesselle.org/folio/) qui contient les jeux de données utilisés par la suite :

```{r, eval=FALSE}
install.packages("folio")
```

::: {.rmdtip}
La plupart des packages publiés sur le CRAN font l'objet de mises à jour régulières. Pour maintenir à jour les packages installés sur votre ordinateur, la fonction `old.packages()` permet de lister les packages pour lesquels il existe une nouvelle version et `update.packages()` permet de télécharger et d'installer les nouvelles versions.
:::

Installer un nouveau package est une condition nécessaire, mais pas suffisante, pour pouvoir l'utiliser. Au lancement, R ne charge pas tous les packages installés, mais uniquement les packages de base^[La liste des packages chargés par défaut au lancement de R peut être obtenue avec `getOption('defaultPackages')`.]. Dans l'exemple suivant, si on utilise la fonction `data()` pour charger le jeux de données `intcal20` du package *folio* sans que ce dernier soit chargé. R ne sait pas où chercher l'objet et retourne un avertissement :

```{r, warning=TRUE, cache=FALSE}
data(intcal20)
```

Il est donc nécessaire de charger un package à l'aide de la fonction `library()` avant de pouvoir l'utiliser^[Dans le cas présent, une alternative serait de spécifier l'argument `package` de la fonction `data()`.] :

```{r}
library("folio")
data(intcal20)
```

## Obtenir de l'aide {#aide}

```{r, echo=FALSE}
base_pkg <- getOption('defaultPackages')
names(base_pkg) <- base_pkg

n_base_pkg <- vapply(
  X = base_pkg,
  FUN = function(pkg) length(ls(paste0('package:', pkg))),
  FUN.VALUE = numeric(1)
)
```

Lorsque vous ne savez pas comment utiliser une fonction particulière (difficile de mémoriser les `r sum(n_base_pkg)` fonctions des packages de base), votre premier réflexe doit être de [consulter la documentation](https://fr.wikipedia.org/wiki/RTFM_(expression)). La documentation couvre l'ensemble des fonctions, jeux de données et autres objets présents dans les différents packages. 

Pour un objet donné, on peut consulter la documentation associée en utilisant soit la fonction `help()`, soit l'opérateur `?`. Par exemple, pour accéder à l'aide de la fonction `round()` :

```{r, eval=FALSE}
help(round)

?round
```

Si l'objet recherché appartient à un package qui n'est pas chargé, R ne saura pas où chercher la documentation. Dans l'exemple suivant, la fonction `lda()` appartient au package *MASS* qui n'est pas chargé :

```{r}
help(lda)
```

Pour accéder à la documentation, il faudra alors charger le package au préalable ou le spécifier dans la fonction `help()` :

```{r, eval=FALSE}
help(lda, package = "MASS")
```

Si on ignore le nom de la fonction à utiliser, deux approches permettent d'explorer la documentation :

* On peut parcourir la documentation d'un package particulier, dont on sait qu'il doit contenir la fonction recherchée (par exemple, `help(package = "MASS")` permet d'afficher le sommaire de la documentation du package *MASS*).
* On peut rechercher dans l'aide par mot-clé à l'aide de l'opérateur `??` ou de la fonction `help.search()`.

Par exemple, pour chercher toutes les pages de la documentation contenant le terme "correlation" :

```{r, eval=FALSE}
help.search("correlation")

??correlation
```

Toutes les pages d'aide sont structurées de la même façon. Généralement, on y trouve au moins les sections suivantes :

*Description*
: Une courte description de ce que fait la fonction.

*Usage*
: Un exemple d'utilisation de la fonction présentant l'ensemble des arguments et leurs éventuelles valeurs par défaut.

*Arguments*
: La liste des arguments de la fonction précisant leur nom, leur rôle et la valeur ou le type d'objet qui est attendu.

*Details*
: Une explication détaillée du comportement de la fonction.

*Value*
: Une description de ce qui est retourné lorsque la fonction est exécutée.

*References*
: Les références bibliographiques associées à la fonction.

*See Also*
: Une suggestion de fonctions similaires.

*Examples*
: Quelques exemples illustrant différents cas d'utilisation de la fonction. Ces exemples peuvent être exécutés directement avec la fonction `example()`.

Pour exécuter les exemples illustrant la documentation de la fonction `mean()` : 

```{r, eval=FALSE}
example(mean)
```

::: {.rmdtip}
Si vous faites face à une difficulté, il fort probable quelqu'un se soit déjà posé la même question que vous et que la réponse se trouve sur [Stack Overflow](https://stackoverflow.com/questions/tagged/r) ou sur les listes de diffusions [R-help](https://stat.ethz.ch/mailman/listinfo/r-help) et [R-devel](https://stat.ethz.ch/mailman/listinfo/r-devel) (actives depuis 1996). Dans le cas contraire, vous pourrez y exposer votre problème, mais il vous faudra apprendre à [écrire des exemples reproductibles](#reprex).
:::

# Vecteurs {#r-vector}

Le vecteur (`vector`) est la structure de base de R, à partir de laquelle toutes les autres sont construites (fig. \@ref(fig:r-vector-types)). Un vecteur est simplement un ensemble d'**éléments**.

Un vecteur peut être un [vecteur atomique](#r-atomic) (`atomic`), si tous ses éléments sont de même **type**, ou une [liste](#r-list) (`list`), si ses éléments sont de types différents (tab. \@ref(tab:r-data-structures)). Un vecteur peut également avoir des [**attributs**](#attributs) (sorte de métadonnées).

(ref:r-vector-types) Les types d'objets de R. D'après @wickham2019.

```{r r-vector-types, echo=FALSE, fig.cap="(ref:r-vector-types)"}
DiagrammeR::grViz(
  "digraph {
  graph [rankdir = BT]
  
  node [shape = plaintext, fontname = arial]
  vector; atomic; list; 'data.frame';
  logical; integer; double; character
  
  {atomic list} -> vector
  'data.frame' -> list
  {logical integer double character} -> atomic
  }",
  height = 400
)
```

Table: (\#tab:r-data-structures) Structures de données des objets de R.

| Dimensions | Objet homogène | Objet hétérogène |
|:-----------|:---------------|:-----------------|
| 1          | `atomic`       | `list`           |
| 2          | `matrix`       | `data.frame`     |
| $n$        | `array`        | -                |

## Vecteurs atomiques (`atomic`) {#r-atomic}

Un vecteur atomique possède deux propriétés : son type et sa longueur (le nombre d'éléments qu'il contient). Les quatre principaux types de R sont les suivants :

* `logical` : booléen.
* `integer` : nombre entier.
* `double` : nombre réel, avec ou sans partie décimale.
* `character` : chaîne de caractère.

### Création

Chacun de ces types possède une syntaxe particulière pour former des vecteur contenant un unique élément (scalaires) :

```{r}
x <- TRUE          # logical
x <- 1L            # integer
x <- 10.5          # double
x <- "archéologie" # character
```

* Un vecteur logique ne peut pendre que deux valeurs `TRUE` (vrai) ou `FALSE` (faux). `TRUE` et `FALSE` sont des mots réservés dans R : ils ne peuvent pas être utilisés comme identifiants pour nommer des variables ou des fonctions.
* Un nombre réel sans partie décimale sera toujours interprété comme étant de type `double` et non de type `integer`.
* Un vecteur de type `integer` s'écrit avec une syntaxe particulière : les nombres doivent être suivis d'un `L` pour les distinguer du type `double` et ne doivent pas avoir de partie décimale.
* Une chaîne de caractère doit toujours être encadrée par des guillemets simples (`'`) ou doubles (`"`). Si les guillemets sont manquantes, R l'interprétera comme un nom d'objet (et cherchera l'objet correspondant).

La fonction `c()` (*combine*) permet de construire des vecteurs longs :

```{r}
vec_log <- c(TRUE, FALSE, TRUE) # logical
vec_int <- c(1L, 2L, 3L)        # integer
vec_num <- c(1.2, 2.1, 3.2)     # double
vec_cha <- c("A", "B", "C")     # character
```

### Description

La fonction `typeof()` permet de connaitre le type d'un vecteur et la fonction `length()` sa longueur :

```{r}
typeof(vec_cha)

length(vec_cha)
```

La famille de fonctions `is.*()` permet de tester si un vecteur est d'un type particulier :

```{r}
is.logical(vec_log)

is.integer(vec_int)

is.double(vec_num)

is.character(vec_cha)
```

### Conversion {#conversion}

Tous les éléments d'un vecteur atomique sont du même type. Lors de la combinaison d'éléments de types différents, R va réaliser une conversion implicite pour tenter de représenter tous les éléments du vecteur de manière raisonnable. Le type du vecteur final est alors déterminé par la hiérarchie `logical` < `integer` < `double` < `character`.

Un vecteur contenant au moins une chaîne de caractères sera donc de type `character` :

```{r}
x <- c(1, "B", 3)
typeof(x)

x <- c(TRUE, "B", TRUE)
typeof(x)
```

Un vecteur contenant au moins un nombre réel sera de type `double` (même s'il ne possède pas de partie décimale) :

```{r}
x <- c(1L, 2.1, 3L)
typeof(x)

x <- c(TRUE, 2.1, TRUE)
typeof(x)
```

La création d'un `integer` avec une partie décimale sera automatiquement converti en type `double` avec un avertissement :

```{r, warning=TRUE}
x <- 10.5L
typeof(x)
```

Il est possible de convertir explicitement un vecteur d'un type à l'autre à l'aide de la famille de fonctions `as.*()` :

```{r}
as.integer(c(1.2, 2.1, 3.2))

as.numeric(c(TRUE, FALSE, TRUE))

as.character(c(1.2, 2.1, 3.2))
```

Les valeurs d'un vecteur numérique peuvent être converties en valeurs logiques : les valeurs égales à 0 deviennent `FALSE`, tout autre valeur non nulle devient `TRUE` :

```{r}
as.logical(c(1, 0, 3))
```

En cas de conversion impossible, des [valeurs manquantes](#valeurs-manquantes) sont générées et un avertissement est retourné :

```{r, warning=TRUE}
as.numeric(c("A", "B", "C"))
```

### Attributs {#attributs}

Les attributs d'un vecteur peuvent être vus comme des métadonnées : des données qui fournissent des informations sur les données du vecteur. 

Les attributs peuvent être spécifiés individuellement à l'aide de la fonction `attr()`, sous la forme de paires associant un nom et une valeur. Dans l'exemple suivant, deux attributs nommés `a` et `b` sont associés au vecteur `x` avec pour valeurs `"xyz"` et `1 2 3`, respectivement : 

```{r}
x <- 1:5

attr(x, "a") <- "xyz"
attr(x, "a")

attr(x, "b") <- 1:3
attr(x, "b")
```

::: {.rmdnote}
La syntaxe particulière `attr(x, "a") <- "xyz"` indique qu'il s'agit d'une fonction de [remplacement](#subset). Ces fonctions particulières modifient en place l'objet correspondant au premier argument (`x`).
:::

L'utilisation des attributs requiert un peu de prudence, car à quelques exceptions près les attributs ne sont pas conservés lors d'opérations sur les vecteurs (comme lors de l'[extraction de sous-ensembles](#subset)). Il existe cependant deux attributs particuliers qui sont généralement conservés : les noms (`names`) et la dimension (`dim`, qui transforme un vecteur en [matrice](#r-matrix)).

Il est possible d'associer des noms aux différents éléments d'un vecteur, soit au moment de sa création, soit *a posteriori* avec la fonction `names()` (qui permet également d'extraire les noms) :

```{r}
# Un nom est associé à chaque élément
x <- c(a = 1, b = 2, c = 3, d = 4, e = 5)
x

# Les noms sont spécifiés à l'aide d'un vecteur
names(x) <- c("f", "g", "h", "i", "j")
x

# Extraire les noms des différents éléments
names(x)

# Supprimer les noms
names(x) <- NULL
names(x)

x
```

::: {.rmdnote}
L'utilisation des attributs permet de créer des vecteurs particuliers, appelés `factor`, qui représentent des [variables qualitatives](#variables-qualitatives) (nominales ou ordinales).
:::

## Listes (`list`) {#r-list}

Une liste est un vecteur particulier, dont les éléments peuvent être de n'importe quel type. Une liste peut être créée avec avec la fonction `list()` :

```{r}
# Création d'une liste contenant 4 éléments
x <- list(
  TRUE,
  1L,
  c(1.2, 2.1),
  c("X", "Y", "Z")
)
x

# Une liste est un objet de type 'list'
typeof(x)

# Longueur de la liste (nombre d'éléments)
length(x)

# Longueur des différents éléments de la liste
lengths(x)

# Les éléments de la liste peuvent être nommés
names(x) <- c("a", "b", "c", "d")
x
```

Les listes permettent ainsi de créer et de manipuler des objets complexes, qui peuvent contenir d'autres listes (on parle alors de vecteurs récursifs) :

```{r}
x <- list(
  list(
    c(TRUE, FALSE),
    c("X", "Y", "Z")
  ), 
  c(1, 2)
)
x
```

La fonction `c()` permet de combiner plusieurs listes en une seule :

```{r}
x <- c(
  list(
    c(TRUE, FALSE),
    c("X", "Y", "Z")
  ), 
  list(1, 2)
)
x
```

Un vecteur atomique est converti en liste avant d'être combiné :

```{r}
x <- c(
  list(
    c(TRUE, FALSE),
    c("X", "Y", "Z")
  ), 
  c(1, 2)
)
x
```

## Matrices (`matrix` et `array`) {#r-matrix}

Un vecteur peut être transformé en un tableau à deux (`matrix`) ou plusieurs (`array`) dimensions, en spécifiant l'attribut `dim`. Une matrice, au sens mathématique, est un tableau rectangulaire à deux dimensions : une matrice possède $m$ lignes et $n$ colonnes et contient $m \times n$ éléments du même type.

```{r}
# Soit un vecteur contenant 12 éléments
x <- 1:12
x

# Le vecteur est transformé en une matrice de 2 lignes et 6 colonnes
dim(x) <- c(2, 6)
dim(x)
x
```

Les caractéristiques d'une matrice peuvent être retrouvées :

```{r}
typeof(x) # Type des éléments
length(x) # Nombre d'éléments (valeurs)
nrow(x)   # Nombre de lignes
ncol(x)   # Nombre de colonnes
```

La fonction `matrix()` permet de créer des matrices en spécifiant le nombre de lignes et de colonnes :

```{r}
# Par défaut, une matrice est remplie colonne par colonne
x <- matrix(1:12, nrow = 3, ncol = 4)
x

# Ce comportement peut être modifié
y <- matrix(1:12, nrow = 3, ncol = 4, byrow = TRUE)
y
```

Plusieurs matrices peuvent être combinées en une seule, par lignes (`rbind()`) ou par colonnes (`cbind()`) :

```{r}
# Combine les lignes de deux matrices
rbind(x, y)

# Combine les colonnes de deux matrices
cbind(x, y)
```

Enfin, il est possible de spécifier/extraire les noms de lignes et de colonnes avec les fonctions `rownames()` et `colnames()` ou avec la fonction `dimnames()` :

```{r}
rownames(x) <- c("X", "Y", "Z")
colnames(x) <- c("A", "B", "C", "D")
dimnames(x)

x

dimnames(y) <- list(c("X", "Y", "Z"), c("A", "B", "C", "D"))
rownames(y)
colnames(y)

y
```

## Tableaux de données (`data.frame`) {#r-dataframe}

Le `data.frame` est probablement le concept le plus important de R : il permet de représenter un tableau de données rectangulaire dont les colonnes peuvent contenir des informations de différentes natures. Un `data.frame` est un cas particulier de `list` (fig. \@ref(fig:r-vector-types)) dont tous les éléments sont nommés et ont la même longueur : chaque élément correspond à une colonne du tableau^[Ainsi, la fonction `names()` est équivalente à `rownames()` et la fonction `length()` retourne le nombre de colonne du tableau (équivalent à `ncol()`).]. Chaque colonne d'un `data.frame` peut ainsi être d'un type différent (contrairement aux matrices dont tous les éléments sont du même type) :

```{r}
x <- data.frame(
  a = 1:3,
  b = c("x", "y", "z")
)
x
```

Un `data.frame` est une liste :

```{r}
typeof(x) # Type list
length(x) # Nombre d'éléments (colonnes)
```

Un `data.frame` est un tableau à deux dimensions :

```{r}
nrow(x) # Nombre de lignes
ncol(x) # Nombre de colonnes
```

Lignes et colonnes d'un `data.frame` sont nommées :

```{r}
rownames(x) # Noms de lignes
colnames(x) # Noms de colonnes
```

::: {.rmdnote}
Sauf instruction spécifique lors de la création d'un `data.frame`, les noms de lignes sont générés automatiquement à partir d'une séquence de nombres entiers. Malgré les apparences, il s'agit bien de noms de lignes (de type `character`) et ils ne doivent pas être confondu avec les indices des lignes.
:::

Comme pour les matrices, il est possible de combiner les lignes ou les colonnes de plusieurs `data.frame` en un seul tableau de données avec `rbind()` et `cbind()`. Dans le cas de la combinaison de colonnes, il pourra être préférable de réaliser des [jointures](#jointures).

# Extraction et remplacement {#subset}

R possède un mécanisme très puissant pour naviguer parmi les valeurs d'un objet, afin d'en extraire ou d'en remplacer tout ou partie. Ce mécanisme obéit cependant à des règles parfois complexes et peut aboutir à des résultats inattendus si elles ne sont pas bien comprises.

La façon la plus simple de sélectionner ou d'extraire des valeurs consiste à utiliser les opérateurs `[` ou `[[` : `[` permet d'extraire un sous-ensemble, tandis que `[[` permet d'extraire un unique élément. Cette distinction correspond aux relations d'[appartenance](https://fr.wikipedia.org/wiki/Appartenance_(math%C3%A9matiques)) et d'[inclusion](https://fr.wikipedia.org/wiki/Inclusion_(math%C3%A9matiques)) de la théorie des ensembles en mathématiques^[Par exemple, si $M$ est un ensemble (collection) tel que $M = \{1,2,3\}$, alors $1$, $2$ et $3$ sont des éléments de $M$, tandis que $\{1,2\}$ ou $\{3\}$ sont des sous-ensembles de $M$.] (cette distinction peut paraître un peu obscure au premier abord, mais prend tout son sens lors de la manipulation de [listes](#subset-list)).

Ces opérateurs peuvent être utilisés conjointement avec l'affectation (`<-`) pour remplacer des valeurs. On écrira ainsi : `x[i] <- y` où `i` correspond à l'indice (position) des valeurs à remplacer dans le vecteur `x` et `y` correspond au vecteur de nouvelles valeurs.

## Vecteurs atomiques {#subset-atomic}

Il existe différentes façons d'extraire un sous-ensemble d'éléments au sein d'un vecteur à l'aide de l'opérateur `[` :

```{r}
x <- c(1.3, 2.4, 3.5, 4.6, 5.7)
```

* Il est possible de spécifier les indices (positions) des éléments à conserver ou à enlever avec des nombres entiers :
  ```{r}
  # Sélection du premier, troisième et cinquième élément
  x[c(1, 3, 5)]
  
  # Suppression du second et du quatrième élément
  x[-c(2, 4)]
  
  # Zéro est un cas particulier
  # (retourne un vecteur de longueur nulle)
  x[0]
  ```
* Il est possible de spécifier si oui (`TRUE`) ou non (`FALSE`) on souhaite conserver des éléments :
  ```{r}
  x[c(TRUE, FALSE, TRUE, FALSE, TRUE)]
  ```
* Si rien n'est spécifié, le vecteur d'origine est retourné :
  ```{r}
  x[]
  ```
* Si les éléments sont nommés, on peut les sélectionner par leur nom :
  ```{r}
  names(x) <- c("a", "b", "c", "d", "e")
  x[c("a", "c", "e")]
  ```

L'utilisation de `[[` permet d'extraire un seul et unique élément au lieu d'un sous-ensemble. Dans le cas des vecteurs atomiques, la différence entre `[` et `[[` n'est pas évidente^[Hormis qu'une tentative de sélection de plusieurs éléments avec `[[` produira une erreur.] et est sans doute mieux illustrée avec un exemple :

```{r}
x[1] # L'attribut names est conservé (sous-ensemble)

x[[1]] # L'attribut names n'est pas conservé (élément)
```

Les éléments sélectionnés peuvent être remplacés en affectant de nouvelles valeurs :

```{r}
# Remplacement du premier et du troisième élément
x[c(1, 3)] <- c(100, 300)
x
```

Lors de l'affectation de nouvelles valeurs dans un vecteur existant, il faut veiller à plusieurs aspects :

* La duplication d'indices :
  ```{r}
  x <- 1:5
  x[c(1, 1, 1)] # Duplique les valeurs
  ```
* L'ordre des indices :
  ```{r}
  x <- 1:5
  x[c(5, 3, 1)] # Change l'ordre des valeurs
  ```
* Les mécanismes de [conversions implicites](#conversion) :
  ```{r}
  x <- 1:5
  typeof(x)
  
  x[c(1, 3)] <- c(100.1, 300.3)
  typeof(x)
  ```
* La taille du vecteur de remplacement. Si ce dernier est trop petit, il sera **recyclé** : ses valeurs seront réutilisées autant que nécessaire :
  ```{r}
  x <- 1:5
  x[c(1, 2, 3, 4)] <- c(100, 200)
  x
  ```

## Listes {#subset-list}

L'extraction de sous-ensembles dans une liste s'opère de la même façon que pour un vecteur atomique :

```{r}
x <- list(
  a = c(TRUE, FALSE),
  b = c(1, 2, 3, 4, 5),
  c = c("X", "Y", "Z")
)
x

# Sélection du premier et du troisième élément
x[c(1, 3)] # Par position

x[c("a", "c")] # Par nom
```

L'opérateur `[` retourne toujours une liste, y compris lorsqu'un unique élément est sélectionné. Pour extraire un unique élément *hors* de la liste, il est possible d'utiliser l'opérateur `[[` :

```{r}
y <- x[1]
y
typeof(y)

z <- x[[1]]
z
typeof(z)
```

Si les éléments de la liste sont nommés, on peut extraire un unique élément en le sélectionnant par son nom avec `[[` ou avec l'opérateur `$` (dollar) :

```{r}
x[["a"]]

x$a
```

Cette distinction entre `[` et `[[` est particulièrement importante lorsqu'on souhaite remplacer des valeurs dans une liste (puisque `[` retourne toujours une liste, la valeur de remplacement doit également être une liste) :

```{r}
x[1] <- list(1:10)
x

x[[1]] <- c(TRUE, FALSE)
x
```

L'opérateur `[[` permet également de supprimer un élément dans une liste en lui affectant la valeur `NULL` :

```{r}
x[[2]] <- NULL
x
```

## Matrices {#subset-matrix}

La sélection d'un sous-ensemble dans un tableau à deux dimensions (`matrix` ou `array`) est une généralisation de la sélection dans un vecteur. Il suffit de spécifier les indices des lignes et des colonnes, séparés par une virgule :

```{r}
x <- matrix(1:12, nrow = 3, ncol = 4)
rownames(x) <- c("x", "y", "z")
colnames(x) <- c("A", "B", "C", "D")
x

# Sélection des lignes 2 à 3 et des colonnes 1 à 3
x[2:3, 1:3]

x[-1, -4]

x[c(FALSE, TRUE, TRUE), c("A", "B", "C")]
```

Si rien n'est spécifié, toutes les lignes ou toutes les colonnes sont sélectionnées :

```{r}
# Sélection de toutes les lignes et des colonnes 1 à 3
x[, 1:3]

# Sélection de toutes les colonnes et des lignes 2 à 3
x[2:3, ]
```

Par défaut, `[` **simplifie** les résultats à la plus petite dimension possible. La sélection d'une unique valeur, d'une unique ligne ou d'une unique colonne, ne retourne donc pas une matrice mais un vecteur. La structure de l'objet d'origine peut cependant être conservée à l'aide de l'argument `drop` :

```{r}
# Sélection de la première colonne
x[, 1] # Retourne un vecteur

x[, 1, drop = FALSE] # Retourne une matrice
```

::: {.rmdwarning}
Un vecteur sans attribut `dim` n'a pas de dimension et ne doit pas être confondu avec une matrice à une seule ligne ou une seule colonne !
:::

Les matrices sont des [vecteurs possédant un attribut particulier](#r-matrix) (`dim`), il est donc également possible de sélectionner un sous-ensemble à l'aide d'un unique vecteur (souvenez-vous que les matrices sont remplies par colonnes) :

```{r}
# Sélection des première et troisième valeurs
x[c(1, 3)]

# Remplacement des première et troisième valeurs
x[c(1, 3)] <- 0
x
```

Enfin, il est possible d'utiliser une matrice pour sélectionner un sous-ensemble d'un tableau à deux dimensions ou plus. Cette matrice doit contenir les coordonnées (lignes et colonnes) des valeurs à sélectionner. La première colonne doit ainsi contenir les indices des lignes à sélectionner, la seconde colonne les indices des colonnes et ainsi de suite pour les cas de dimensions supérieures (`array`) :

```{r}
# On veut sélectionner les cellules (1,2), (2,3) et (3,4)
y <- matrix(c(1, 2, 3, 2, 3, 4), ncol = 2)

# La première colonne contient les indices des lignes
# La seconde colonne contient les indices des colonnes
y

x[y]
```

## Tableaux de données {#subset-dataframe}

Pour extraire ou remplacer des valeurs dans un `data.frame`, on peut utiliser deux stratégies. Les `data.frame` ont en effet les caractéristiques des listes et des matrices :

```{r}
x <- data.frame(
  a = c(TRUE, FALSE, TRUE, TRUE),
  b = c(1, 2, 3, 4),
  c = c("A", "B", "C", "D")
)

# Comme une liste !
x[c("a", "b", "c")] # Colonnes nommées "a", "b" et "c"
x[[2]]              # Deuxième colonne uniquement
x$b                 # Colonne nommée "b"

# Comme une matrice !
x[, c("a", "b", "c")]
x[, 2]
x[, "b", drop = FALSE]
```

# Opérateurs binaires {#operateurs}

## Opérateurs arithmétiques

Les opérateurs arithmétiques (tab. \@ref(tab:operateurs-math)) permettent de réaliser les opérations élémentaires :

```{r}
x <- 1
y <- 2

# Addition
x + y

# Soustraction
x - y

# Multiplication
x * y

# Exponentiation
x^y
```

Table: (\#tab:operateurs-math) Les principaux opérateurs arithmétiques de R.

| Opérateur | Description    |
|:---------:|:---------------|
| `+`       | addition       |
| `-`       | soustraction   |
| `*`       | multiplication |
| `/`       | division       |
| `^`       | exponentiation |

Une des particularités des R est de *vectoriser* de nombreuses opérations. Cela signifie que les opérations mathématiques sont réalisées élément par élément :

```{r}
x <- 1:5
y <- 6:10

# Addition des éléments de x et y, un à un
# Équivaut à réaliser 1 + 6, 2 + 7, 3 + 8, 4 + 9 et 5 + 10
x + y
```

Cet aspect est important dans le cas d'opérations sur des matrices (souvenez-vous, une matrice est simplement un vecteur avec un attribut de dimension et est remplie colonne par colonne) :

```{r}
# Une matrice de 5 lignes et 2 colonnes
x <- matrix(1:10, ncol = 2)
x

# Un vecteur de 10 éléments
y <- 1:10
y

# Les éléments de x et y sont additionnés un à un
x + y
```

Si deux vecteurs n'ont pas la même longueur, R va **recycler** le plus court des deux et le réutiliser autant que nécessaire. Si la taille de l'objet le plus long n'est pas multiple de la taille de l'objet le plus court, un avertissement sera également retourné :

```{r, warning=TRUE}
# Un vecteur de 5 éléments
i <- 1:5
i

# Les éléments de x et i sont additionnés un à un
# i est recyclé silencieusement
x + i

# Un vecteur de 3 éléments
j <- 1:3
j

# Les éléments de x et j sont additionnés un à un
# j est recyclé avec un message d'avertissement
x + j
```

## Opérateurs logiques

Les opérateurs logiques (tab. \@ref(tab:operateurs-logiques)) permettent comparer des valeurs. Ces comparaisons se présentent sous la forme d'un test (la condition est-elle vraie ou fausse ?) et retournent donc un vecteur de type `logical` :

```{r}
# x contient un unique élément
x <- 1

# La valeur de x est-elle égale à 0 ?
x == 0

# La valeur de x est-elle différente de 1 ?
x != 1

# La valeur de x est-elle supérieure à 0 ?
x > 0

# La valeur de x est-elle inférieure à 2 ?
x < 2
```

Table: (\#tab:operateurs-logiques) Les opérateurs logiques de R.

| Opérateur | Comparaison           |
|:---------:|:----------------------|
| `>`       | strictement supérieur |
| `>=`      | supérieur ou égal     |
| `<`       | strictement inférieur |
| `<=`      | inférieur ou égal     |
| `==`      | égal                  |
| `!=`      | différent             |
| `&`       | ET                    |
| `|`       | OU                    |

Les opérateurs `&` (ET) et `|` (OU) permettent de combiner plusieurs conditions et de réaliser des comparaisons plus complexes. Dans ce cas, chaque condition est évaluée séparément, puis les résultats sont comparés :

```{r}
# La valeur de x est-elle comprise entre 0 et 2 ?
x > 0 & x < 2

# La valeur de x est-elle égale à 0 ou 1 ?
x == 0 | x == 1

# ET
TRUE & TRUE
TRUE & FALSE
FALSE & FALSE

# OU
TRUE | TRUE
TRUE | FALSE
FALSE | FALSE

# NEGATION
!TRUE
!FALSE
```

Souvenez-vous, R vectorise de nombreuses opérations. La comparaison de deux objets est réalisée élément par élément :

```{r}
x <- c(1, 4, 3, 6, 5)
y <- c(3, 2, 5, 4, 7)

# Comparaison des éléments de x et y, un à un
# Équivaut à tester si 1 < 3, 2 < 4, 3 < 5, 4 < 6 et 5 < 7
x < y

# Toutes les valeurs de x sont-elles inférieures à y ?
all(x < y)

# Au moins une des valeurs de x est-elle inférieure à y ?
any(x < y)
```

::: {.rmdwarning}
Prenez garde aux valeurs manquantes ! Si une comparaison est réalisée avec une valeur manquante, le résultat sera une valeur manquante uniquement s'il est ambigu :

```{r}
TRUE & NA
FALSE & NA

TRUE | NA
FALSE | NA
```
:::

Utilisés conjointement avec `[` et `<-`, les opérateurs logiques permettent de [filtrer](#filtrer) et [nettoyer](#nettoyer) facilement ses données :

```{r}
x <- 0:10
x

# Extraire les valeurs supérieures à 5
x[x > 5]

# Remplacer les 0 par des valeurs manquantes
x[x == 0] <- NA
x
```

# Structures de contrôle

## Alternatives

Les alternatives permettent d'exécuter différentes instructions en fonction du résultat d'un test logique.

### Test "si..."

::: {.float-right}
```{r flow-if, echo=FALSE, out.width='25%'}
DiagrammeR::grViz(
  'digraph {
  splines = ortho
  
  node [shape = diamond, fontname = arial, width = 1.25]
    T [label="test", group=g1]
  node [shape = box, fontname = arial, width = 1]
    A [label="instruction 1"]
    B [label="instruction 2", group=g1]
  node [shape = point, width = 0]
    d1 [group=g1]; d2 [group=g1]; d3 [group=g1]
  
  edge [minlen = 1, fontname = arial]
    d1 -> T
    T -> A [label="  oui"]
    A -> d2 -> B
    T -> d2 [arrowhead = none, label="  non"]
    B -> d3 [arrowhead = none]
  
  { rank = same; T; A }
  }',
  width = 200, height = 150
)
```
:::

L'instruction `if` permet d'exécuter un bloc de code, uniquement *si* une condition est vraie :

```{r}
x <- 1

# On définit un test logique
# On encadre les instructions à exécuter avec des accolades
if (x > 0) {
  print("Texte affiché si la condition est vraie.")
}
```

### Test "si... sinon..."

::: {.float-right}
```{r flow-ifelse, echo=FALSE, out.width='25%'}
DiagrammeR::grViz(
  'digraph {
  splines = ortho
  
  node [shape = diamond, fontname = arial, width = 1.25]
    T [label="test", group=g1]
  node [shape = box, fontname = arial, width = 1]
    A [label="instruction 1", group=g2]
    B [label="instruction 2", group=g3]
    C [label="instruction 3", group=g1]
  node [shape = point, width = 0]
    d1 [group=g1]; d2 [group=g1]; d3 [group=g1]
    d4 [group=g2]; d5 [group=g3]
    d6 [group=g2]; d7 [group=g3]
  
  edge [minlen = 1, fontname = arial]
    d1 -> T
    d4 -> T -> d5 [arrowhead = none]
    d4 -> A [label="  oui"]
    d5 -> B [label="  non"]
    A -> d6 [arrowhead = none]
    B -> d7 [arrowhead = none]
    d6 -> d2 -> d7 [arrowhead = none]
    d2 -> C
    C -> d3 [arrowhead = none]
  
  { rank = same; T; d4; d5 }
  { rank = same; A; B }
  { rank = same; d2; d6; d7 }
  }',
  width = 200, height = 200
)
```
:::

Il est possible de définir plusieurs choix en utilisant alternativement les instructions `if` et `else` :

```{r}
x <- 1

# On définit un test logique
if (x < 0) {
  print("Texte affiché si la condition est vraie.")
} else {
  print("Texte affiché si la condition est fausse.")
}
```

::: {.float-right}
```{r flow-elseif, echo=FALSE, out.width='25%'}
DiagrammeR::grViz(
  'digraph {
  splines = ortho
  
  node [shape = diamond, fontname = arial, width = 1.25]
    T1 [label="test 1", group=g1]
    T2 [label="test 2", group=g1]
  node [shape = box, fontname = arial, width = 1]
    A [label="instruction 1", group=g2]
    B [label="instruction 2", group=g2]
    C [label="instruction 3", group=g1]
  node [shape = point, width = 0]
    d1 [group=g1]; d2 [group=g1]; d3 [group=g1];
    d4 [group=g3]; d5 [group=g3]; d6 [group=g3]
  
  edge [minlen = 1, fontname = arial]
    d1 -> T1
    T1 -> A [label="  oui"]
    T1 -> T2 [label="  non"]
    T2 -> B [label="  oui"]
    T2 -> d2 [arrowhead = none, label="  non"]
    d2 -> C
    A -> d4 -> d5 [arrowhead = none]
    B -> d5 -> d6 [arrowhead = none]
    d2 -> d6 [dir = back]
    C -> d3 [arrowhead = none]
  
  { rank = same; T1; A; d4 }
  { rank = same; T2; B; d5 }
  { rank = same; d2; d6 }
  }',
  width = 200, height = 200
)
```
:::

Plusieurs alternatives peuvent être définies en utilisant conjointement `else` et `if`. On peut alors enchaîner autant de clauses "sinon si" que nécessaire et, éventuellement, définir une clause finale qui sera exécutée uniquement si aucune autre clause n'a été vérifiée :

```{r, message=TRUE}
x <- "chien"

if (x == "chat") {
  # Si la première condition est vraie
  message("x est un chat.")
} else if (x == "chien") {
  # Si la première condition est fausse et la seconde est vraie
  message("x est un chien.")
} else {
  # Si toutes les conditions sont fausses
  message("x est un animal inconnu.")
}
```

### Test "selon..."

L'instruction `switch` permet de choisir un bloc de code *selon* la valeur d'une variable.

L'exemple précédent peut être réécrit comme suit :

```{r, message=TRUE}
x <- "chien"

switch (
  x,
  chat = message("x est un chat."),
  chien = message("x est un chien."),
  message("x est un animal inconnu.")
)
```

## Boucles

Les boucles sont un moyen simple pour répéter des instructions en faisant varier un paramètre. 

### Boucles itératives

Une boucle itérative est contrôlée un compteur : une variable qui va prendre une valeur différente à chaque itération de la boucle. Le nombre d'exécutions de la boucle est connu à l'avance.

L'instruction `for` permet d'écrire des boucles en définissant un compteur et en spécifiant les instructions à répéter :

```{r}
# On définit une variable i (le nom est libre)
# On précise que i va prendre successivement les valeurs 1 à 5
# On encadre les instructions à répéter avec des accolades
for (i in 1:5) {
  print(i) # A chaque itération, on affiche la valeur de i
}
```

Dans l'exemple suivant, on cherche à extraire et à afficher successivement chaque élément d'un vecteur :

```{r}
# Création d'un vecteur contenant 5 éléments
x <- c(1.2, 6.5, 6.1, 5.9, 6.4)

# Faire varier i de 1 à 5
for (i in 1:5) {
  # Extraire la i-ème valeur de x
  # Stocker cette valeur dans l'objet k
  k <- x[i]
  # Afficher la valeur de k
  print(k)
}
```

Dans l'exemple précédent, la valeur de `k` a été remplacée à chaque itération de la boucle. Si on veut récupérer les résultats des différentes étapes, il va falloir au préalable créer un objet vide susceptible de recevoir progressivement les différentes valeurs. La définition de cet objet implique d'anticiper les résultats de la boucle pour qu'il ait la structure adéquate :

```{r}
# Créer un vecteur vide pour récupérer les résultats
# Le vecteur à la même longueur que le nombre d'itérations
k <- vector(mode = "numeric", length = 5)
k

# Faire varier i de 1 à 5
for (i in 1:5) {
  # Extraire la i-ème valeur de x
  # Affecter cette valeur à la i-ème position de k
  k[i] <- x[i]
}
k
```

Dans le cas d'un tableau à deux dimensions, écrire une même série d'instructions pour chaque ligne ou colonne individuellement peut rapidement s'avérer fastidieux. On peut ainsi mettre à profit les boucles pour n'écrire qu'une seule fois ces instructions et les appliquer à toutes les lignes ou toutes les colonnes.

Imaginons que l'on souhaite connaitre le nombre total de tessons de différents types de céramiques retrouvés sur un ensemble de sites archéologiques. Si nos données sont [correctement structurées](#tidy-data), on peut calculer cette somme pour chacune des colonnes d'un tableau de données^[Il s'agit d'un exemple : dans le cas présent une boucle n'est pas nécessaire, R possède deux fonctions qui permettent de calculer la somme des lignes (`rowSums()`) ou des colonnes (`colSums()`) d'un tableau.] :

```{r}
# On charge les données d'exemple
# help(compiegne, package = "folio")
data(compiegne, package = "folio")

# Le tableau possède 5 lignes et 16 colonnes
dim(compiegne)

# On crée un vecteur vide pour récupérer les résultats
# (16 valeurs sont attendues : la somme de chaque colonne)
resultats <- vector(mode = "numeric", length = 16)

# On fait varier i de 1 à 16
for (i in 1:16) {
  # On extrait la i-ème colonne
  colonne_i <- compiegne[, i]
  # On calcule la somme de la colonne
  total_i <- sum(colonne_i)
  # On stocke la somme dans la i-ème position du vecteur de résultats
  resultats[i] <- total_i
}
resultats
```

### Boucles de parcours

R possède une famille de fonctions qui permettent d'appliquer facilement des instructions aux différents éléments d'un objet. Les principales fonctions de cette famille sont :

* `apply()` : applique une fonction sur les lignes ou les colonnes d'une matrice (ou sur les dimensions supérieures d'un `array`).
* `lapply()` et `vapply()` : appliquent une fonction sur les différents éléments d'un vecteur ou d'une liste.
* `tapply()` : applique une fonction sur différents groupes de valeurs.

L'exemple précédent peut ainsi être simplifié avec `apply()` :

```{r}
# Inutile de créer un objet vide au préalable
somme <- apply(
  X = compiegne, 
  MARGIN = 2, # Appliquer aux lignes (1) ou aux colonnes (2)
  FUN = sum
)
somme
```

::: {.rmdwarning}
La fonction `apply()` est conçue pour être utilisée sur une matrice (ou un `array`). Lorsqu'elle est utilisée sur un `data.frame`, elle va donc le convertir en `matrix`. Les éléments d'une matrice sont tous du même type : si les colonnes du `data.frame` sont de types différents, les règles de [conversions implicites](#conversion) s'appliquent et peuvent entraîner des erreurs (par exemple lorsque les colonnes numériques sont transformées en chaînes de caractères, empêchant ainsi l'exécution d'une fonction mathématique).
:::

Dans le cas d'un `data.frame`, il est préférable d'utiliser `lapply()` lorsqu'on souhaite appliquer une même fonction aux différentes colonnes :

```{r}
x <- data.frame(
  a = c(3.6, 7.5, 7.2, 7.7, 4.8),
  b = c(5.8, 7.5, 1.5, 5.7, 2.3),
  c = c(7.2, 6.4, 3.3, 3.1, 8.1)
)

# Convertir toutes les colonnes en integer
y <- lapply(X = x, FUN = as.integer)
y
```

`lapply()` retourne une simple liste, mais en utilisant une sélection vide, il est possible de conserver la structure du `data.frame` initial :
 
```{r}
# Convertir toutes les colonnes en integer
# Conserve la structure du data.frame
# (mais remplace les données d'origine)
x[] <- lapply(X = x, FUN = as.integer)
x
```

`vapply()` est similaire à `lapply()`, mais peut être plus pratique à utiliser. `vapply()` simplifie le résultat final et retourne un vecteur ou, si cela est approprié, une matrice (comme pour `apply()`, faites attention aux règles de [conversions implicites](#conversion)). De plus, le comportement de `vapply()` est prédictible : il est nécessaire de spécifier avec l'argument `FUN.VALUE` le type de résultat retourné.

```{r}
# On spécifie le résultat de l'application de FUN aux éléments de X
# Celui-ci doit être un vecteur de type integer et de longueur 5
z <- vapply(X = x, FUN = as.integer, FUN.VALUE = integer(5))
z
```

Si le résultat de l'application de la fonction `FUN` à chaque élément de `X` ne correspond pas à la spécification, l'exécution du code est interrompue et une erreur est retournée :

```{r, error=TRUE}
# La longueur du vecteur retourné par FUN ne correspond pas
vapply(X = x, FUN = as.integer, FUN.VALUE = integer(3))

# Le type du vecteur retourné par FUN ne correspond pas
vapply(X = x, FUN = as.integer, FUN.VALUE = character(5))
```

`tapply()` permet d'appliquer une même fonction à différents sous-ensembles d'un objet. Cette fonction est particulièrement pratique pour calculer des indicateurs statistiques par groupes :

```{r}
# On dispose de 5 mesures d'un paramètre quelconque
valeurs <- c(6.8, 6.4, 5.8, 8.5, 8.8)
# Chaque mesure appartient à un groupe particulier (A ou B)
groupes <- c("A", "A", "B", "A", "B")

# On calcule la moyenne de chaque groupe
moy <- tapply(X = valeurs, INDEX = groupes, FUN = mean)
moy
```

### Boucles à précondition

::: {.float-right}
```{r flow-while, echo=FALSE, out.width='25%'}
DiagrammeR::grViz(
  'digraph {
  splines = ortho
  
  node [shape = diamond, fontname = arial, width = 1.25]
    T [label="test", group=g1]
  node [shape = box, fontname = arial, width = 1]
    A [label="instruction 1", group=g1]
    B [label="instruction 2", group=g1]
  node [shape = point, width = 0]
    d1 [group=g1]; d2 [group=g1]; d4 [group=g1];
    d5 [group=g2]; d7 [group=g2]; d8 [group=g2];
    d3 [group=g3]; d6 [group=g3]
  
  edge [minlen = 1, fontname = arial]
    d6 -> d2 -> T
    d6 -> d3 -> A [arrowhead = none]
    d1 -> d2 [arrowhead = none]
    T -> A [label="  non"]
    T -> d5 [arrowhead = none]
    d5 -> d7 [arrowhead = none, label="  oui"] 
    d7 -> d8 [arrowhead = none]
    B -> d8 [dir = back]
    B -> d4 [arrowhead = none]
    
  { rank = same; T; d5 }
  { rank = same; A; d3; d7 }
  { rank = same; B; d8 }
  { rank = same; d2; d6 }
  
  }',
  width = 200, height = 200
)
```
:::

Une dernière possibilité, d'un usage peut-être moins courant, consiste à exécuter des instructions tant qu'une condition est vérifié. Cette boucle peut être considérée comme la répétition d'une instruction `if` *tant que* la valeur d'un test est vraie. Ainsi, une condition est vérifiée avant chaque itération de la boucle : si la condition est vraie (`TRUE`) les instructions sont exécutées, si la condition est fausse (`FALSE`) la boucle s'arrête sans exécuter les instructions.

```{r}
# On définit la valeur initiale d'une variable
i <- 0

# On répète les instructions tant que i est inférieur à 5
while (i < 5) {
  print(i)   # Afficher la valeur de i
  i <- i + 1 # Incrémenter la valeur i
}
```

::: {.rmdnote}
Il convient d'être prudent avec l'usage de l'instruction `while`, car une mauvaise définition de la condition d'arrêt peut créer une boucle infinie.
:::
